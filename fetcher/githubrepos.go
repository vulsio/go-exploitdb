package fetcher

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/inconshreveable/log15"
	"golang.org/x/xerrors"

	"github.com/deepfactor-io/exploitdb/git"
	"github.com/deepfactor-io/exploitdb/models"
	"github.com/deepfactor-io/exploitdb/util"
)

const repoURL string = "https://github.com/nomi-sec/PoC-in-GitHub.git"

type githubRepo struct {
	Name        string    `json:"name"`
	FullName    string    `json:"full_name"`
	Description string    `json:"description"`
	URL         string    `json:"html_url"`
	Star        int       `json:"stargazers_count"`
	Fork        int       `json:"forks_count"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// FetchGitHubRepos :
func FetchGitHubRepos(stars, forks int) (exploits []models.Exploit, err error) {
	dir := filepath.Join(util.CacheDir(), "pocs")
	updatedFiles, err := git.CloneOrPull(repoURL, dir)
	if err != nil {
		return nil, xerrors.Errorf("error in pocsrc clone or pull: %w", err)
	}

	var targets []map[string]struct{}
	targetFiles := 0
	for year := 1999; year <= time.Now().Year(); year++ {
		target, err := util.FilterTargets(fmt.Sprint(year), updatedFiles)
		if err != nil {
			return nil, xerrors.Errorf("Failed to filter target files: %w", err)
		}

		if len(target) != 0 {
			targets = append(targets, target)
			targetFiles += len(target)
		}
	}
	if targetFiles == 0 {
		log15.Debug("PoC-in-GitHub: no updated file")
		return nil, nil
	}
	log15.Debug(fmt.Sprintf("PoC-in-GitHub updated files: %d", targetFiles))

	entries := map[string][]githubRepo{}
	for _, target := range targets {
		err = util.FileWalk(dir, target, func(r io.Reader, path string) error {
			content, err := io.ReadAll(r)
			if err != nil {
				return err
			}

			var pocs []githubRepo
			if err = json.Unmarshal(content, &pocs); err != nil {
				return xerrors.Errorf("Failed to decode GitHubRepoJSON: %w", err)
			}

			dirPaths := strings.Split(path, "/")
			cveID := strings.Split(dirPaths[len(dirPaths)-1], ".")[0]
			entries[cveID] = pocs
			return nil
		})
		if err != nil {
			return nil, xerrors.Errorf("error in PoC-in-GitHub walk: %w", err)
		}
	}

	for cveID, pocs := range entries {
		for _, poc := range pocs {
			if poc.Star < stars || poc.Fork < forks {
				continue
			}

			githubRepoExploit := models.Exploit{
				ExploitUniqueID: fmt.Sprintf("%s-%x", models.GitHubRepositoryType, md5.Sum([]byte(cveID+poc.URL))),
				ExploitType:     models.GitHubRepositoryType,
				URL:             poc.URL,
				CveID:           cveID,
				Description:     poc.Description,
				GitHubRepository: &models.GitHubRepository{
					Star:      poc.Star,
					Fork:      poc.Fork,
					CreatedAt: poc.CreatedAt,
					UpdatedAt: poc.UpdatedAt,
					CveID:     cveID,   // included for simpler queries  without joining with exploits table
					URL:       poc.URL, // included for simpler queries  without joining with exploits table
				},
			}
			exploits = append(exploits, githubRepoExploit)
		}
	}

	sort.Slice(exploits, func(i, j int) bool {
		return (exploits[i].GitHubRepository.Star + exploits[i].GitHubRepository.Fork) > (exploits[j].GitHubRepository.Star + exploits[j].GitHubRepository.Fork)
	})

	return exploits, nil
}
