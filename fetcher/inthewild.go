package fetcher

import (
	"bytes"
	"crypto/md5"
	"database/sql"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/glebarez/sqlite"
	"golang.org/x/xerrors"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"github.com/deepfactor-io/exploitdb/models"
	"github.com/deepfactor-io/exploitdb/util"
)

// https://www.sqlite.org/fileformat.html
var sqlite3HeaderMagic = []byte("SQLite format 3\x00")

const dbURL string = "https://github.com/gmatuz/inthewilddb/blob/master/inthewild.db?raw=true"

type exploit struct {
	CVEID        string         `gorm:"column:exploits.id"`
	Description  sql.NullString `gorm:"column:vulns.description"`
	ReferenceURL string         `gorm:"column:exploits.referenceURL"`
	TimeStamp    time.Time      `gorm:"column:exploits.timestamp"`
	Source       string         `gorm:"column:exploits.source"`
	Type         string         `gorm:"column:exploits.type"`
}

// FetchInTheWild :
func FetchInTheWild(debugSQL bool) ([]models.Exploit, error) {
	if err := os.MkdirAll(util.CacheDir(), 0700); err != nil {
		return nil, xerrors.Errorf("Failed to mkdir: %w", err)
	}
	dbPath := filepath.Join(util.CacheDir(), "inthewild.db")
	f, err := os.Create(dbPath)
	if err != nil {
		return nil, xerrors.Errorf("Failed to create inthewild.db in cache directory. err: %w", err)
	}
	defer f.Close()

	res, err := util.FetchURL(dbURL)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch inTheWild DB. err: %w", err)
	}
	if !bytes.Equal(res[:16], sqlite3HeaderMagic) {
		return nil, xerrors.Errorf("Failed to fetch inTheWild DB. err: not sqlite3 database")
	}
	if n, err := f.Write(res); err != nil {
		return nil, xerrors.Errorf("Failed to write db. err: %w", err)
	} else if n != len(res) {
		return nil, xerrors.Errorf("Failed to write db. err: not enough bytes written")
	}

	gormConfig := gorm.Config{
		DisableForeignKeyConstraintWhenMigrating: true,
		Logger: logger.New(
			log.New(os.Stderr, "\r\n", log.LstdFlags),
			logger.Config{
				LogLevel: logger.Silent,
			},
		),
	}

	if debugSQL {
		gormConfig.Logger = logger.New(
			log.New(os.Stderr, "\r\n", log.LstdFlags),
			logger.Config{
				SlowThreshold: time.Second,
				LogLevel:      logger.Info,
				Colorful:      true,
			},
		)
	}
	db, err := gorm.Open(sqlite.Open(dbPath), &gormConfig)
	if err != nil {
		return nil, xerrors.Errorf("Failed to open inTheWild DB. err: %w", err)
	}
	sqlDB, err := db.DB()
	if err != nil {
		return nil, xerrors.Errorf("Failed to get DB Object. err : %w", err)
	}
	defer sqlDB.Close()

	rows, err := db.
		Table("exploits").
		Select("exploits.id, vulns.description, exploits.referenceURL, exploits.timestamp, exploits.source, exploits.type").
		Joins("LEFT JOIN vulns ON vulns.id = exploits.id").
		Rows()
	if err != nil {
		return nil, xerrors.Errorf("Failed to select exploits. err: %w", err)
	}
	defer rows.Close()

	exploits := []models.Exploit{}
	var exploit exploit
	for rows.Next() {
		if err := rows.Scan(&exploit.CVEID, &exploit.Description, &exploit.ReferenceURL, &exploit.TimeStamp, &exploit.Source, &exploit.Type); err != nil {
			return nil, xerrors.Errorf("Failed to scan rows. err: %w", err)
		}

		exploits = append(exploits, models.Exploit{
			ExploitType:     models.InTheWildType,
			ExploitUniqueID: fmt.Sprintf("%s-%x", models.InTheWildType, md5.Sum([]byte(exploit.CVEID+exploit.ReferenceURL+exploit.Source+exploit.Type))),
			URL:             exploit.ReferenceURL,
			Description:     exploit.Description.String,
			CveID:           exploit.CVEID,
			InTheWild: &models.InTheWild{
				TimeStamp: exploit.TimeStamp,
				Source:    exploit.Source,
				Type:      exploit.Type,
			},
		})
	}

	return exploits, nil
}
